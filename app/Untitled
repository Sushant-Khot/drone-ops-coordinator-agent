from datetime import datetime


class AssignmentEngine:
    def __init__(self):
        pass

    # --------------------------------------------------
    # MAIN MATCHING FUNCTION
    # --------------------------------------------------
    def find_best_match(self, pilots, drones, location=None, urgent=False, required_certs=None, required_capability=None):
        """
        Returns best pilot + drone match.

        urgent=False -> only picks Available resources
        urgent=True  -> can reshuffle Busy resources (least disruption)

        required_certs example: ["DGCA", "BVLOS"]
        required_capability example: "Thermal"
        """

        if required_certs is None:
            required_certs = []

        # STEP 1: filter pilots
        filtered_pilots = self._filter_pilots(pilots, location, urgent, required_certs)

        # STEP 2: filter drones
        filtered_drones = self._filter_drones(drones, location, urgent, required_capability)

        if filtered_pilots and filtered_drones:
            return {
                "pilot": filtered_pilots[0],
                "drone": filtered_drones[0],
                "reason": "Best available pilot and drone found"
            }

        # --------------------------------------------------
        # URGENT MODE RESHUFFLING LOGIC
        # --------------------------------------------------
        if urgent:
            # If no available, allow reassignment from busy but least disruption
            candidate_pilot = self._find_least_disruptive_pilot(pilots, location, required_certs)
            candidate_drone = self._find_least_disruptive_drone(drones, location, required_capability)

            if candidate_pilot and candidate_drone:
                return {
                    "pilot": candidate_pilot,
                    "drone": candidate_drone,
                    "reason": f"Reassigned pilot {candidate_pilot.get('Name')} and drone {candidate_drone.get('Serial')} (least disruption)"
                }

        return None

    # --------------------------------------------------
    # PILOT FILTER
    # --------------------------------------------------
    def _filter_pilots(self, pilots, location, urgent, required_certs):
        eligible = []

        for p in pilots:
            status = str(p.get("Status", "")).lower()
            pilot_loc = str(p.get("Location", "")).lower()

            # Normal mode: only available pilots
            if not urgent:
                if status not in ["available", "free", "active"]:
                    continue

            # location match if provided
            if location:
                if location.lower() not in pilot_loc:
                    continue

            # cert check
            pilot_certs = self._parse_list(p.get("Certifications", ""))
            if not self._has_all_certs(pilot_certs, required_certs):
                continue

            eligible.append(p)

        # Sort pilots: prioritize Available first
        eligible.sort(key=lambda x: str(x.get("Status", "")).lower() != "available")
        return eligible

    # --------------------------------------------------
    # DRONE FILTER
    # --------------------------------------------------
    def _filter_drones(self, drones, location, urgent, required_capability):
        eligible = []

        for d in drones:
            status = str(d.get("Status", "")).lower()
            drone_loc = str(d.get("Location", "")).lower()
            capability = str(d.get("Capability", "")).lower()

            # Normal mode: only available drones
            if not urgent:
                if status not in ["available", "ready", "free"]:
                    continue

            # Exclude maintenance always
            if "maintenance" in status:
                continue

            # location match if provided
            if location:
                if location.lower() not in drone_loc:
                    continue

            # capability check
            if required_capability:
                if required_capability.lower() not in capability:
                    continue

            eligible.append(d)

        eligible.sort(key=lambda x: str(x.get("Status", "")).lower() != "available")
        return eligible

    # --------------------------------------------------
    # URGENT MODE - PILOT REASSIGNMENT
    # --------------------------------------------------
    def _find_least_disruptive_pilot(self, pilots, location, required_certs):
        """
        Choose pilot whose current assignment ends earliest (least disruption)
        """
        candidates = []

        for p in pilots:
            status = str(p.get("Status", "")).lower()
            pilot_loc = str(p.get("Location", "")).lower()

            if location and location.lower() not in pilot_loc:
                continue

            pilot_certs = self._parse_list(p.get("Certifications", ""))
            if not self._has_all_certs(pilot_certs, required_certs):
                continue

            # only consider busy pilots for reassignment
            if status in ["busy", "assigned", "deployed"]:
                end_date = p.get("AssignedEnd")
                if end_date:
                    candidates.append((p, end_date))

        if not candidates:
            return None

        # sort by earliest end date
        candidates.sort(key=lambda x: self._safe_date(x[1]))
        return candidates[0][0]

    # --------------------------------------------------
    # URGENT MODE - DRONE REASSIGNMENT
    # --------------------------------------------------
    def _find_least_disruptive_drone(self, drones, location, required_capability):
        candidates = []

        for d in drones:
            status = str(d.get("Status", "")).lower()
            drone_loc = str(d.get("Location", "")).lower()
            capability = str(d.get("Capability", "")).lower()

            if "maintenance" in status:
                continue

            if location and location.lower() not in drone_loc:
                continue

            if required_capability and required_capability.lower() not in capability:
                continue

            if status in ["busy", "assigned", "deployed"]:
                end_date = d.get("AssignedEnd")
                if end_date:
                    candidates.append((d, end_date))

        if not candidates:
            return None

        candidates.sort(key=lambda x: self._safe_date(x[1]))
        return candidates[0][0]

    # --------------------------------------------------
    # HELPERS
    # --------------------------------------------------
    def _parse_list(self, value):
        if not value:
            return []
        if isinstance(value, list):
            return value
        return [x.strip() for x in str(value).split(",") if x.strip()]

    def _has_all_certs(self, pilot_certs, required_certs):
        pilot_certs_lower = [c.lower() for c in pilot_certs]
        for cert in required_certs:
            if cert.lower() not in pilot_certs_lower:
                return False
        return True

    def _safe_date(self, date_str):
        """
        Converts YYYY-MM-DD to datetime
        """
        try:
            return datetime.strptime(date_str, "%Y-%m-%d")
        except:
            return datetime.max
